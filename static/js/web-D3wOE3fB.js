import{Fp as e,ot as t,tt as n}from"./index-hvLbsAjx.js";function r(e){try{let t=new URL(e),n=new URL(window.location.href);return t.origin!==n.origin}catch{return!1}}function i(){return{startTime:Date.now(),requestId:`req_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,retryCount:0,data:{}}}var a=class{isCrossOrigin(e){return r(e)}createInterceptorContext(){return i()}},o=class{constructor(e){this.proxyServerUrl=e}setProxyServer(e){this.proxyServerUrl=e,console.log(`ðŸ”§ Proxy server set to: ${e}`)}async request(e,t){let n=i();try{let i=await this.executeRequestInterceptors(e,n,t),{url:a,method:o=`GET`,headers:s={},data:c,params:l,timeout:u=3e4,responseType:d=`json`,followRedirects:f=!0}=i,p=a;if(l){let e=new URLSearchParams(l);p+=(a.includes(`?`)?`&`:`?`)+e.toString()}let m=p,h={method:o,headers:s,redirect:f?`follow`:`manual`};this.proxyServerUrl&&r(p)&&(console.log(`ðŸ”§ Using proxy server for: ${p}`),m=`${this.proxyServerUrl}/proxy/${encodeURIComponent(p)}`);let g=new AbortController,_=setTimeout(()=>g.abort(),u);h.signal=g.signal;try{c&&[`POST`,`PUT`,`PATCH`].includes(o)&&(typeof c==`string`?h.body=c:(h.body=JSON.stringify(c),s[`Content-Type`]||=`application/json`));let e=await fetch(m,h);clearTimeout(_);let r;switch(d){case`text`:r=await e.text();break;case`blob`:r=await e.blob();break;case`arraybuffer`:r=await e.arrayBuffer();break;case`json`:default:try{r=await e.json()}catch{r=await e.text()}break}let i={};e.headers.forEach((e,t)=>{i[t]=e});let a={status:e.status,statusText:e.statusText,headers:i,data:r,url:e.url};return a=await this.executeResponseInterceptors(a,n,t),a}catch(r){clearTimeout(_);let a={message:r instanceof Error?r.message:`Unknown error`,config:i,originalError:r},o=await this.executeErrorInterceptors(a,n,t);if(o)return o;if(this.proxyServerUrl&&m.includes(this.proxyServerUrl))return console.warn(`âš ï¸ Proxy request failed, trying direct request: ${r}`),this.request({...e,url:p},t);throw a}}catch(t){throw t.config?t:{message:t instanceof Error?t.message:`Unknown error`,config:e,originalError:t}}}async get(e,t){return this.request({...e,method:`GET`},t)}async post(e,t){return this.request({...e,method:`POST`},t)}async put(e,t){return this.request({...e,method:`PUT`},t)}async patch(e,t){return this.request({...e,method:`PATCH`},t)}async delete(e,t){return this.request({...e,method:`DELETE`},t)}async executeRequestInterceptors(e,t,n){let r={...e};for(let e of n)if(!(!e.enabled||!e.interceptor.onRequest)){if(e.options.scope){let{urlPattern:t,methods:n}=e.options.scope;if(t&&!new RegExp(t).test(r.url)||n&&r.method&&!n.includes(r.method))continue}try{r=await Promise.resolve(e.interceptor.onRequest(r))}catch(t){throw console.error(`[Interceptor ${e.id}] Request interceptor error:`,t),t}}return r}async executeResponseInterceptors(e,t,n){let r={...e};for(let e of n)if(!(!e.enabled||!e.interceptor.onResponse))try{r=await Promise.resolve(e.interceptor.onResponse(r))}catch(t){throw console.error(`[Interceptor ${e.id}] Response interceptor error:`,t),t}return r}async executeErrorInterceptors(e,t,n){for(let t of n)if(!(!t.enabled||!t.interceptor.onError))try{let n=await Promise.resolve(t.interceptor.onError(e));if(n)return n}catch(e){console.error(`[Interceptor ${t.id}] Error interceptor error:`,e)}}},s=class{constructor(e,t){this.streamControllers=new Map,this.streamCounter=0,this.proxyServerUrl=e,this.notifyListeners=t}async streamRequest(e){let t=`stream_${++this.streamCounter}`,{url:n,method:i=`POST`,headers:a={},data:o,params:s,timeout:c=6e4,followRedirects:l=!0}=e,u=n;if(s){let e=new URLSearchParams(s);u+=(n.includes(`?`)?`&`:`?`)+e.toString()}let d=u;this.proxyServerUrl&&r(u)&&(console.log(`ðŸ”§ Using proxy server for streaming: ${u}`),d=`${this.proxyServerUrl}/proxy/${encodeURIComponent(u)}`);let f=new AbortController;this.streamControllers.set(t,f);let p=setTimeout(()=>{f.abort(),this.notifyListeners(`streamStatus`,{streamId:t,status:`error`,error:`Request timeout`})},c);try{let e={method:i,headers:{...a,Accept:`text/event-stream, application/json, text/plain, */*`},signal:f.signal,redirect:l?`follow`:`manual`};return o&&[`POST`,`PUT`,`PATCH`].includes(i)&&(typeof o==`string`?e.body=o:(e.body=JSON.stringify(o),a[`Content-Type`]||(e.headers={...e.headers,"Content-Type":`application/json`}))),console.log(`ðŸŒŠ Starting stream request: ${t} to ${d}`),fetch(d,e).then(async e=>{if(clearTimeout(p),!e.ok)throw Error(`HTTP ${e.status}: ${e.statusText}`);let n={};e.headers.forEach((e,t)=>{n[t]=e}),this.notifyListeners(`streamStatus`,{streamId:t,status:`started`,statusCode:e.status,headers:n});let r=e.body?.getReader(),i=new TextDecoder;if(!r)throw Error(`Response body is not readable`);try{for(;;){let{done:e,value:n}=await r.read();if(e){this.notifyListeners(`streamChunk`,{streamId:t,data:``,done:!0}),this.notifyListeners(`streamStatus`,{streamId:t,status:`completed`}),this.streamControllers.delete(t);break}let a=i.decode(n,{stream:!0});this.notifyListeners(`streamChunk`,{streamId:t,data:a,done:!1})}}catch(e){if(e.name===`AbortError`)this.notifyListeners(`streamStatus`,{streamId:t,status:`cancelled`});else throw e}}).catch(e=>{clearTimeout(p);let n=e instanceof Error?e.message:`Unknown error`;this.notifyListeners(`streamChunk`,{streamId:t,data:``,done:!0,error:n}),this.notifyListeners(`streamStatus`,{streamId:t,status:`error`,error:n}),this.streamControllers.delete(t)}),{streamId:t}}catch(e){throw clearTimeout(p),this.streamControllers.delete(t),e}}async cancelStream(e){let{streamId:t}=e,n=this.streamControllers.get(t);n&&(n.abort(),this.streamControllers.delete(t),this.notifyListeners(`streamStatus`,{streamId:t,status:`cancelled`}))}getStreamControllers(){return this.streamControllers}},c=class{constructor(e,t){this.sseConnections=new Map,this.connectionCounter=0,this.proxyServerUrl=e,this.notifyListeners=t}async startSSE(e){let t=`sse_${++this.connectionCounter}`,{url:n,headers:i={},withCredentials:a=!1,reconnectTimeout:o=3e3}=e,s=n;this.proxyServerUrl&&r(n)&&(console.log(`ðŸ”§ Using SSE proxy for: ${n}`),s=`${this.proxyServerUrl}/sse-proxy/${encodeURIComponent(n)}`);let c=new EventSource(s);return this.sseConnections.set(t,c),c.onopen=()=>{this.notifyListeners(`sseOpen`,{connectionId:t,status:`connected`})},c.onmessage=e=>{this.notifyListeners(`sseMessage`,{connectionId:t,type:`message`,data:e.data,id:e.lastEventId})},c.onerror=()=>{this.notifyListeners(`sseError`,{connectionId:t,error:`Connection error`})},{connectionId:t}}async stopSSE(e){let{connectionId:t}=e,n=this.sseConnections.get(t);n&&(n.close(),this.sseConnections.delete(t),this.notifyListeners(`sseClose`,{connectionId:t,status:`disconnected`}))}async createSSEConnection(e){let t=`sse_${++this.connectionCounter}`,{url:n,headers:i={},reconnect:a={}}=e,{enabled:o=!0,initialDelay:s=1e3,maxDelay:c=3e4,maxAttempts:l=10}=a,u=0,d=s,f=()=>{let e=n;this.proxyServerUrl&&r(n)&&(console.log(`ðŸ”§ Using SSE proxy for: ${n}`),e=`${this.proxyServerUrl}/sse-proxy/${encodeURIComponent(n)}`);let i=new EventSource(e);this.sseConnections.set(t,i),i.onopen=()=>{u=0,d=s,this.notifyListeners(`sseConnectionChange`,{connectionId:t,status:`connected`})},i.onmessage=e=>{this.notifyListeners(`sseMessage`,{connectionId:t,type:`message`,data:e.data,id:e.lastEventId})},i.onerror=()=>{this.notifyListeners(`sseConnectionChange`,{connectionId:t,status:`error`,error:`Connection error`}),o&&u<l?setTimeout(()=>{u++,d=Math.min(d*2,c),i.close(),f()},d):this.sseConnections.delete(t)},i.addEventListener(`error`,e=>{this.notifyListeners(`sseMessage`,{connectionId:t,type:`error`,data:`Connection error`})})};return this.notifyListeners(`sseConnectionChange`,{connectionId:t,status:`connecting`}),f(),{connectionId:t,status:`connecting`}}async closeSSEConnection(e){let{connectionId:t}=e,n=this.sseConnections.get(t);n&&(n.close(),this.sseConnections.delete(t),this.notifyListeners(`sseConnectionChange`,{connectionId:t,status:`disconnected`}))}getSSEConnections(){return this.sseConnections}},l=class{constructor(e){this.wsConnections=new Map,this.connectionCounter=0,this.notifyListeners=e}async createWebSocketConnection(e){let t=`ws_${++this.connectionCounter}`,{url:n,protocols:r,headers:i,timeout:a=1e4}=e;return new Promise((e,i)=>{let o=new WebSocket(n,r);this.wsConnections.set(t,o);let s=setTimeout(()=>{o.close(),this.wsConnections.delete(t),i(Error(`WebSocket connection timeout`))},a);o.onopen=()=>{clearTimeout(s),this.notifyListeners(`webSocketConnectionChange`,{connectionId:t,status:`connected`}),e({connectionId:t,status:`connected`})},o.onmessage=e=>{this.notifyListeners(`webSocketMessage`,{connectionId:t,data:e.data,type:typeof e.data==`string`?`text`:`binary`})},o.onerror=()=>{clearTimeout(s),this.notifyListeners(`webSocketConnectionChange`,{connectionId:t,status:`error`,error:`WebSocket connection error`})},o.onclose=()=>{this.wsConnections.delete(t),this.notifyListeners(`webSocketConnectionChange`,{connectionId:t,status:`disconnected`})},this.notifyListeners(`webSocketConnectionChange`,{connectionId:t,status:`connecting`})})}async closeWebSocketConnection(e){let{connectionId:t}=e,n=this.wsConnections.get(t);n&&(n.close(),this.wsConnections.delete(t))}async sendWebSocketMessage(e){let{connectionId:t,message:n}=e,r=this.wsConnections.get(t);if(r&&r.readyState===WebSocket.OPEN)r.send(n);else throw Error(`WebSocket connection not found or not open`)}getWebSocketConnections(){return this.wsConnections}},u=class{constructor(){this.interceptors=[],this.interceptorCounter=0}async addInterceptor(e,t){let n=`interceptor_${++this.interceptorCounter}`,r={id:n,interceptor:e,options:t||{},enabled:t?.enabled!==!1};return this.interceptors.push(r),this.interceptors.sort((e,t)=>{let n=e.options.priority||0;return(t.options.priority||0)-n}),{id:n,name:t?.name,remove:()=>{this.removeInterceptor(n)},enable:()=>{let e=this.interceptors.find(e=>e.id===n);e&&(e.enabled=!0)},disable:()=>{let e=this.interceptors.find(e=>e.id===n);e&&(e.enabled=!1)},isEnabled:()=>{let e=this.interceptors.find(e=>e.id===n);return e?e.enabled:!1}}}async removeInterceptor(e){let t=typeof e==`string`?e:e.id,n=this.interceptors.findIndex(e=>e.id===t);n!==-1&&this.interceptors.splice(n,1)}async removeAllInterceptors(){this.interceptors=[]}async getInterceptors(){return this.interceptors.map(e=>({id:e.id,name:e.options.name,remove:()=>this.removeInterceptor(e.id),enable:()=>{e.enabled=!0},disable:()=>{e.enabled=!1},isEnabled:()=>e.enabled}))}async executeRequestInterceptors(e){i();let t={...e};for(let e of this.interceptors)if(!(!e.enabled||!e.interceptor.onRequest)){if(e.options.scope){let{urlPattern:n,methods:r}=e.options.scope;if(n&&!new RegExp(n).test(t.url)||r&&t.method&&!r.includes(t.method))continue}try{t=await Promise.resolve(e.interceptor.onRequest(t))}catch(t){throw console.error(`[Interceptor ${e.id}] Request interceptor error:`,t),t}}return t}async executeResponseInterceptors(e){i();let t={...e};for(let e of this.interceptors)if(!(!e.enabled||!e.interceptor.onResponse))try{t=await Promise.resolve(e.interceptor.onResponse(t))}catch(t){throw console.error(`[Interceptor ${e.id}] Response interceptor error:`,t),t}return t}async executeErrorInterceptors(e){i();for(let t of this.interceptors)if(!(!t.enabled||!t.interceptor.onError))try{let n=await Promise.resolve(t.interceptor.onError(e));if(n)return n}catch(e){console.error(`[Interceptor ${t.id}] Error interceptor error:`,e)}}getInterceptorsInternal(){return this.interceptors}},d=class extends e{constructor(){super(),this.proxyServerUrl=null,this.globalProxyConfig=null,this.proxyRequestCount=0,this.proxyLastSuccessTime=null,this.proxyLastError=null,this.mcpClients=new Map,this.mcpTransports=new Map,this.connectionCounter=0,this.utilsManager=new a,this.httpManager=new o(this.proxyServerUrl),this.streamManager=new s(this.proxyServerUrl,this.notifyListeners.bind(this)),this.sseManager=new c(this.proxyServerUrl,this.notifyListeners.bind(this)),this.wsManager=new l(this.notifyListeners.bind(this)),this.interceptorManager=new u,this.detectProxyServer()}async detectProxyServer(){for(let e of[`http://localhost:3002`,`http://127.0.0.1:3002`,`http://localhost:3001`,`http://127.0.0.1:3001`,`http://localhost:8080`,`http://127.0.0.1:8080`])try{let t=new AbortController,n=setTimeout(()=>t.abort(),1e3),r=await fetch(`${e}/health`,{method:`GET`,signal:t.signal});if(clearTimeout(n),r.ok){this.proxyServerUrl=e,this.httpManager.setProxyServer(e),this.streamManager=new s(this.proxyServerUrl,this.notifyListeners.bind(this)),this.sseManager=new c(this.proxyServerUrl,this.notifyListeners.bind(this)),console.log(`ðŸ”§ CORS Proxy server detected at: ${e}`);break}}catch{}this.proxyServerUrl||(console.warn(`âš ï¸ No CORS proxy server detected. Some requests may fail due to CORS.`),console.log(`ðŸ’¡ To enable full functionality, run: node web-proxy-server.js`))}setProxyServer(e){this.proxyServerUrl=e,this.httpManager.setProxyServer(e),this.streamManager=new s(this.proxyServerUrl,this.notifyListeners.bind(this)),this.sseManager=new c(this.proxyServerUrl,this.notifyListeners.bind(this)),console.log(`ðŸ”§ Proxy server set to: ${e}`)}async request(e){let t=this.interceptorManager.getInterceptorsInternal();return this.httpManager.request(e,t)}async get(e){let t=this.interceptorManager.getInterceptorsInternal();return this.httpManager.get(e,t)}async post(e){let t=this.interceptorManager.getInterceptorsInternal();return this.httpManager.post(e,t)}async put(e){let t=this.interceptorManager.getInterceptorsInternal();return this.httpManager.put(e,t)}async patch(e){let t=this.interceptorManager.getInterceptorsInternal();return this.httpManager.patch(e,t)}async delete(e){let t=this.interceptorManager.getInterceptorsInternal();return this.httpManager.delete(e,t)}async streamRequest(e){return this.streamManager.streamRequest(e)}async cancelStream(e){return this.streamManager.cancelStream(e)}async startSSE(e){return this.sseManager.startSSE(e)}async stopSSE(e){return this.sseManager.stopSSE(e)}async createSSEConnection(e){return this.sseManager.createSSEConnection(e)}async closeSSEConnection(e){return this.sseManager.closeSSEConnection(e)}async createWebSocketConnection(e){return this.wsManager.createWebSocketConnection(e)}async closeWebSocketConnection(e){return this.wsManager.closeWebSocketConnection(e)}async sendWebSocketMessage(e){return this.wsManager.sendWebSocketMessage(e)}async createMCPClient(e){let r=`mcp_${++this.connectionCounter}`;try{let i=e.transport||`streamablehttp`,a=e.url;if(!a&&e.sseUrl&&(a=e.sseUrl),!a)throw Error(`URL is required for MCP client (provide either "url" or "sseUrl")`);let o;if(i===`streamablehttp`)throw Error(`StreamableHTTP transport should use mcpClientManager. Use @capacitor/cors-bypass-enhanced web managers directly.`);if(i===`sse`||e.sseUrl)if(this.proxyServerUrl&&this.utilsManager.isCrossOrigin(a)){let e=`${this.proxyServerUrl}/sse-proxy/${encodeURIComponent(a)}`;o=new n(new URL(e))}else o=new n(new URL(a));else throw Error(`Unsupported transport type: ${i}`);let s=new t({name:e.clientInfo.name,version:e.clientInfo.version},{capabilities:{roots:e.capabilities?.roots?{listChanged:!0}:void 0,sampling:e.capabilities?.sampling?{}:void 0}});return await s.connect(o),this.mcpClients.set(r,s),this.mcpTransports.set(r,o),console.log(`âœ… MCP client connected: ${r}`),{connectionId:r,status:`connected`,serverCapabilities:s.getServerCapabilities(),protocolVersion:`2025-03-26`}}catch(e){throw console.error(`âŒ MCP client connection failed:`,e),Error(`Failed to create MCP client: ${e}`)}}async listMCPResources(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{let n=await t.listResources(e.cursor?{cursor:e.cursor}:{});return{resources:n.resources||[],nextCursor:n.nextCursor}}catch(e){throw Error(`Failed to list MCP resources: ${e}`)}}async readMCPResource(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{let n=await t.readResource({uri:e.uri});return{uri:e.uri,mimeType:n.contents?.[0]?.mimeType||`text/plain`,text:n.contents?.[0]?.text||``,blob:n.contents?.[0]?.data}}catch(e){throw Error(`Failed to read MCP resource: ${e}`)}}async listMCPTools(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{let n=await t.listTools(e.cursor?{cursor:e.cursor}:{});return{tools:n.tools||[],nextCursor:n.nextCursor}}catch(e){throw Error(`Failed to list MCP tools: ${e}`)}}async callMCPTool(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{let n=await t.callTool({name:e.name,arguments:e.arguments||{}});return{content:n.content||[],isError:n.isError||!1}}catch(e){throw Error(`Failed to call MCP tool: ${e}`)}}async listMCPPrompts(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{let n=await t.listPrompts(e.cursor?{cursor:e.cursor}:{});return{prompts:n.prompts||[],nextCursor:n.nextCursor}}catch(e){throw Error(`Failed to list MCP prompts: ${e}`)}}async getMCPPrompt(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{let n=await t.getPrompt({name:e.name,arguments:e.arguments||{}});return{description:n.description,messages:n.messages||[]}}catch(e){throw Error(`Failed to get MCP prompt: ${e}`)}}async sendMCPSampling(e){let t=this.mcpClients.get(e.connectionId);if(!t)throw Error(`MCP client not found`);try{return await t.request({method:e.request.method,params:e.request.params})}catch(e){throw Error(`Failed to send MCP sampling request: ${e}`)}}async addInterceptor(e,t){return this.interceptorManager.addInterceptor(e,t)}async removeInterceptor(e){return this.interceptorManager.removeInterceptor(e)}async removeAllInterceptors(){return this.interceptorManager.removeAllInterceptors()}async getInterceptors(){return this.interceptorManager.getInterceptors()}async setGlobalProxy(e){this.globalProxyConfig=e,this.proxyServerUrl&&e.enabled&&(console.log(`ðŸ”§ [Web] Global proxy configured: ${e.type||`http`}://${e.host}:${e.port}`),console.log(`ðŸ’¡ Note: Web platform proxying requires server-side support.`))}async getGlobalProxy(){return this.globalProxyConfig}async clearGlobalProxy(){this.globalProxyConfig=null,this.proxyLastError=null,console.log(`ðŸ”§ [Web] Global proxy configuration cleared`)}async testProxy(e,t){let n=Date.now(),r=t||`https://www.google.com`;if(!e.enabled||!e.host)return{success:!1,error:`Proxy configuration is invalid or disabled`,responseTime:0};try{if(this.proxyServerUrl){let t=await fetch(`${this.proxyServerUrl}/proxy`,{method:`POST`,headers:{"Content-Type":`application/json`},body:JSON.stringify({url:r,method:`HEAD`,proxy:{enabled:!0,type:e.type||`http`,host:e.host,port:e.port,username:e.username,password:e.password}})}),i=Date.now()-n;if(this.proxyRequestCount++,t.ok)return this.proxyLastSuccessTime=Date.now(),this.proxyLastError=null,{success:!0,responseTime:i,statusCode:t.status};{let e=`HTTP ${t.status}`;return this.proxyLastError=e,{success:!1,responseTime:i,statusCode:t.status,error:e}}}else{let e=new AbortController,t=setTimeout(()=>e.abort(),1e4);try{let i=await fetch(r,{method:`HEAD`,mode:`no-cors`,signal:e.signal});return clearTimeout(t),{success:!0,responseTime:Date.now()-n,statusCode:i.status||0}}catch(e){return clearTimeout(t),{success:!1,responseTime:Date.now()-n,error:e.message||`Connection failed`}}}}catch(e){return this.proxyLastError=e.message,{success:!1,responseTime:Date.now()-n,error:e.message||`Proxy test failed`}}}async getProxyStatus(){return{active:this.globalProxyConfig?.enabled??!1,config:this.globalProxyConfig??void 0,requestCount:this.proxyRequestCount,lastError:this.proxyLastError??void 0,lastSuccessTime:this.proxyLastSuccessTime??void 0}}};export{d as CorsBypassWeb};